<?xml version="1.0" encoding="UTF-8"?>
<!-- 
 * Copyright (C) 2016 Dienst voor het kadaster en de openbare registers
 * 
 * This file is part of Imvertor.
 *
 * Imvertor is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Imvertor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Imvertor.  If not, see <http://www.gnu.org/licenses/>.
-->
<xsl:stylesheet 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:UML="omg.org/UML1.3"
    
    xmlns:imvert="http://www.imvertor.org/schema/system"
    xmlns:ext="http://www.imvertor.org/xsl/extensions"
    xmlns:imf="http://www.imvertor.org/xsl/functions"
    xmlns:imvert-result="http://www.imvertor.org/schema/imvertor/application/v20160201"

    xmlns:ekf="http://EliotKimber/functions"

    xmlns:StUF="http://www.egem.nl/StUF/StUF0301" 
    xmlns:bg="http://www.egem.nl/StUF/sector/bg/0310" 
    xmlns:metadata="http://www.kinggemeenten.nl/metadataVoorVerwerking" 
    xmlns:ztc="http://www.kinggemeenten.nl/ztc0310" 
    xmlns:stuf="http://www.egem.nl/StUF/StUF0301" 

    exclude-result-prefixes="xsl UML imvert imvert-result ekf"
    version="2.0">
    
    <xsl:import href="../common/Imvert-common.xsl"/>

    <xsl:param name="prefix" select="'ztc'"/>
    
    <xsl:output indent="yes" method="xml" encoding="UTF-8"/>
    
    <xsl:variable name="xsd-folder-path" select="imf:get-config-string('system','xsd-folder-path')"/>
    
    <xsl:template match="/">
        <root/><!-- dummy output -->
        <xsl:apply-templates select="imvert-result:Application"/>
    </xsl:template>
    
    <xsl:template match="imvert-result:Application">
        <xsl:variable name="schemafile" select="concat($xsd-folder-path,'RESULT.XSD')"/>
        <xsl:variable name="schema" as="element()">
            <xs:schema 
                attributeFormDefault="unqualified" 
                elementFormDefault="qualified" 
                targetNamespace="http://www.kinggemeenten.nl/ztc0310" 
                version="010000" 
                xmlns="http://www.w3.org/2001/XMLSchema">

                <xs:import schemaLocation="file:/d:/projects/validprojects/KING/input/ztc0310/bg0310_simpleTypes.xsd" namespace="http://www.egem.nl/StUF/sector/bg/0310" />
                <xs:import schemaLocation="file:/d:/projects/validprojects/KING/input/ztc0310/StUF0301.xsd" namespace="http://www.egem.nl/StUF/StUF0301" />

                <xs:annotation>
                    <xs:appinfo><xsl:value-of select="concat('Generated by ', $imvertor-version,' at ',current-dateTime())"/></xs:appinfo>
                </xs:annotation>

                <xs:annotation>
                    <xs:documentation>(Gegevensgroeptypen) Basis entiteiten schema voor ztc0310.</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert-result:Class[imf:get-stereotype(.) = 'gegevensgroeptype']" mode="gegevensgroeptype"/>
                
                <xs:annotation>
                    <xs:documentation>(Referentielijsten)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert-result:Class[imf:get-stereotype(.) = 'referentielijst']" mode="referentielijst"/>
                
                <xs:annotation>
                    <xs:documentation>(Basistypen)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert-result:Class[imf:get-stereotype(.) = 'objecttype']" mode="objecttype"/>
                
                <xs:annotation>
                    <xs:documentation>(Kerngegevens)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert-result:Class[imf:get-stereotype(.) = 'objecttype']" mode="kerngegevens"/>
                
                <xs:annotation>
                    <xs:documentation>(Attribuuttypen) Schema met de binnen ztc0310 gebruikte StUF-ZTC simpleTypes.</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert-result:Attribute" 
                    group-by="imf:get-namestruct(.)[3]">
                    <xsl:apply-templates select="current-group()[1]" mode="declare-attribute-type"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Associatietypen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert-result:Association" 
                    group-by="imf:get-namestruct(.)[3]">
                    <xsl:apply-templates select="current-group()[1]" mode="declare-association-type"/>
                </xsl:for-each-group>
                
                <!--
                    Als geen type-ID beschikbaar is, is het een "bare type" (zoals AN80). 
                -->
                <xs:annotation>
                    <xs:documentation>(Simpletypes)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert-result:Attribute[imf:get-typestruct(.)[3] = '']" 
                    group-by="imf:get-namestruct(.)[3]">
                    <xsl:apply-templates select="current-group()[1]" mode="declare-attribute-simpletype"/>
                </xsl:for-each-group>
              
            </xs:schema>
        </xsl:variable>
        <xsl:result-document href="{$schemafile}" method="xml" indent="yes" encoding="UTF-8" exclude-result-prefixes="#all">
            <xsl:apply-templates select="$schema" mode="xsd-cleanup"/>
        </xsl:result-document>
    </xsl:template>
    
    <!-- Groepsattribuutsoort -->
    <xsl:template match="imvert-result:Class" mode="gegevensgroeptype">
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
        
        <xsl:comment select="concat('Groepsattribuutsoort ',$name-struct[4])"/>
        
        <xs:complexType name="{$name-struct[3]}">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="imf:get-documentation(.)"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xsl:comment select="'(Attributes)'"/>
                <xsl:apply-templates select="imvert-result:attributes/imvert-result:Attribute" mode="local-attribute"/>
                <!-- TODO ook bij gegevensgroeptypen?? --> 
                <xsl:comment select="'(Associations)'"/>
                <xsl:apply-templates select="imvert-result:associations/imvert-result:Association" mode="local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                </xsl:apply-templates>
                <xsl:variable name="inkomende-associaties" select="$document//imvert-result:Association[imf:get-type-id(.) = $id]"/>
                <xsl:apply-templates select="$inkomende-associaties" mode="local-association">
                    <xsl:with-param name="richting">inkomend</xsl:with-param>
                </xsl:apply-templates>
            </xs:sequence>
        </xs:complexType>
    </xsl:template>
    
    <xsl:template match="imvert-result:Class" mode="objecttype">
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="hisform-on-attributes" select=".//imvert-result:Attribute[imf:get-history(.)[1]]"/>
        <xsl:variable name="hismate-on-attributes" select=".//imvert-result:Attribute[imf:get-history(.)[2]]"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
       
        <xsl:comment select="concat('Objecttype ',$name-struct[4])"/>
        
        <xs:complexType name="{$name-struct[2]}-basis">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="concat($name-struct[1],': ', imf:get-documentation(.))"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xsl:apply-templates select="imvert-result:attributes/imvert-result:Attribute" mode="local-attribute"/>
                <xs:element ref="StUF:tijdvakGeldigheid" minOccurs="0"/>
                <xs:element ref="StUF:tijdstipRegistratie" minOccurs="0"/>
                <xs:element ref="StUF:extraElementen" minOccurs="0"/>
                <xsl:if test="$hismate-on-attributes">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', $name-struct[2],'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="$hisform-on-attributes">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', $name-struct[2],'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
                <xsl:comment select="'(Associations)'"/>
                <xsl:apply-templates select="imvert-result:associations/imvert-result:Association" mode="local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                </xsl:apply-templates>
                <xsl:variable name="inkomende-associaties" select="$document//imvert-result:Association[imf:get-type-id(.) = $id]"/>
                <xsl:apply-templates select="$inkomende-associaties" mode="local-association">
                    <xsl:with-param name="richting">inkomend</xsl:with-param>
                </xsl:apply-templates>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" fixed="{$name-struct[2]}"/>
            <xs:attributeGroup ref="StUF:entiteit"/>
        </xs:complexType>
    </xsl:template>
    
    <!-- Groepsattribuutsoort -->
    <xsl:template match="imvert-result:Class" mode="referentielijst">
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
        
        <xsl:comment select="concat('Referentelijst ',$name-struct[4])"/>
        
        <xs:complexType name="{$name-struct[3]}-tabel">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="imf:get-documentation(.)"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xsl:apply-templates select="imvert-result:attributes/imvert-result:Attribute" mode="local-attribute"/>
                <xs:element ref="StUF:tijdvakObject" minOccurs="0"/>
                <xs:element ref="StUF:extraElementen" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$name-struct[3]}"/>
            <xs:attribute ref="StUF:scope"/>
            <xs:attribute ref="StUF:verwerkingssoort"/>
        </xs:complexType>
    </xsl:template>
    
    <xsl:template match="imvert-result:Class" mode="kerngegevens">
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="kerngegevens" select="imf:get-kerngegevens(.)"/> <!-- attributes and an association -->
        
        <xsl:comment select="concat('Kerngegevens ',$name-struct[4])"/>
        
        <xs:complexType name="{$name-struct[2]}-kerngegevens">
            <xs:complexContent>
                <xs:restriction base="{concat($prefix,':', $name-struct[2],'-basis')}">
                    <xs:sequence>
                        <xsl:for-each select="$kerngegevens">
                            <xsl:choose>
                                <xsl:when test="self::imvert-result:Attribute">
                                    <xsl:apply-templates select="." mode="local-attribute"/>
                                </xsl:when>
                                <xsl:when test="self::imvert-result:Association">
                                    <xsl:apply-templates select="." mode="local-association">
                                        <xsl:with-param name="kerngegevens" select="true()"/>
                                        <xsl:with-param name="richting" select="'uitgaand'"/>
                                    </xsl:apply-templates>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:sequence select="."/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:for-each>
                    </xs:sequence>
                    <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$name-struct[2]}"/>
                    <xs:attribute ref="StUF:sleutelVerzendend"/>
                    <xs:attribute ref="StUF:sleutelOntvangend"/>
                    <xs:attribute ref="StUF:sleutelGegevensbeheer"/>
                    <xs:attribute ref="StUF:noValue" use="prohibited"/>
                    <xs:attribute ref="StUF:scope" use="prohibited"/>
                    <xs:attribute ref="StUF:verwerkingssoort"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
    </xsl:template>
    
    <!-- Attribuutsoort -->
    <xsl:template match="imvert-result:Attribute" mode="local-attribute">
        
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="type-struct" select="imf:get-typestruct(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        
        <xsl:variable name="type-name-struct" select="imf:get-namestruct($type)"/>
        
        <xsl:comment select="concat('Local attribute ',$name-struct[4])"/>

        <xsl:variable name="typeref">
            <xsl:choose>
                <xsl:when test="$type-struct[1] = 'INDIC'">
                    <xsl:value-of select="'bg:Indicatie-e'"/>
                </xsl:when>
                <xsl:when test="$type-struct[1] = 'URI'">
                    <xsl:value-of select="'bg:Url-e'"/>
                </xsl:when>
                <xsl:when test="$type-struct[2] = 'DATUM'">
                    <xsl:value-of select="'StUF:Datum'"/>
                </xsl:when>
                <xsl:when test="$type-struct[2] = 'OnvolledigeDatum'">
                    <xsl:value-of select="'StUF:DatumMetIndicator'"/>
                </xsl:when>
                <xsl:when test="$type-struct[1] = 'integer'">
                    <xsl:value-of select="concat($prefix, ':', imf:capitalize($name-struct[3]), '-e')"/>
                </xsl:when>
                <xsl:when test="$type-struct[1] = 'string'">
                    <xsl:value-of select="concat($prefix, ':', imf:capitalize($name-struct[3]), '-e')"/>
                </xsl:when>
                <xsl:when test="$type-struct[1] = 'letter'">
                    <xsl:value-of select="concat($prefix, ':', imf:capitalize($name-struct[3]), '-e')"/>
                </xsl:when>
                <xsl:when test="$type-struct[1] = 'DATUM'">
                    <xsl:value-of select="concat($prefix, ':', imf:capitalize($name-struct[3]), '-e')"/>
                </xsl:when>
                <xsl:when test="imf:get-stereotype($type) = 'referentielijst'"> <!-- a reference table -->
                    <!-- 
                        Check if the reference list holds an attribute with the same name. 
                        Use that attribute as the basis for the (simple) type of the attribute. 
                    -->
                    <xsl:variable name="attribute" select="$type//imvert-result:Attribute[imf:get-namestruct(.)[1] = $name-struct[1]]"/>
                    <xsl:variable name="name-struct-att" select="imf:get-namestruct($attribute)"/>
                    <xsl:if test="empty($attribute)">
                        <xsl:value-of select="imf:msg(.,'ERROR','No attribute with same name in reference list', $name-struct[1])"/>
                    </xsl:if>
                    <xsl:value-of select="concat($prefix, ':', imf:capitalize($name-struct-att[3]), '-e')"/>
                </xsl:when>
                <xsl:when test="normalize-space($type-struct[3])"> <!-- a type defined elsewhere -->
                    <xsl:value-of select="concat($prefix, ':', $type-name-struct[3])"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="imf:msg(.,'ERROR','Cannot handle the attribute type', imf:get-construct-name(.))"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xs:element
            name="{$name-struct[3]}" 
            type="{$typeref}" 
            nillable="true" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
            metadata:formeleHistorie="{$history[1]}"
            metadata:materieleHistorie="{$history[2]}"     
        />

    </xsl:template>
    
    <xsl:template match="imvert-result:Association" mode="local-association">
        <xsl:param name="kerngegevens" select="false()"/>
        <xsl:param name="richting" select="'uitgaand'"/>
        
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="type-struct" select="imf:get-typestruct(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert-result:Class"/>
        <xsl:variable name="source-name-struct" select="imf:get-namestruct($source)"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        <xsl:variable name="target-name-struct" select="imf:get-namestruct($target)"/>
        
        <xsl:choose>
            <xsl:when test="$richting = 'uitgaand'">
                <xsl:comment select="concat('Uitgaande relatie ',$name-struct[4])"/>
                
                <xsl:variable name="associatie-naam" select="$name-struct[2]"/>
                <xsl:variable name="heen-typeref" select="concat($prefix, ':', $associatie-naam,if ($kerngegevens) then '-kerngegevens' else '-basis')"/>
                
                <xsl:variable name="target-cardinality" select="if ($history[2]) then 'unbounded' else $cardinality[4]"/> <!-- als materiele historie, dan is target altijd unbounded -->
                <xs:element
                    name="{$name-struct[8]}" 
                    type="{$heen-typeref}" 
                    nillable="true" 
                    minOccurs="0" 
                    maxOccurs="{$target-cardinality}"
                    metadata:formeleHistorie="{$history[1]}"
                    metadata:materieleHistorie="{$history[2]}"     
                />
            </xsl:when>
            <xsl:otherwise>
                <xsl:comment select="concat('Inkomende relatie ',$name-struct[4])"/>
                
                <xsl:variable name="associatie-naam" select="imf:get-taggedvalue(.,'Mnemonic relatiesoort terugrelatie')"/>
                <xsl:variable name="terug-typeref" select="concat($prefix, ':',$associatie-naam ,if ($kerngegevens) then '-kerngegevens' else '-basis')"/>
                
                <xsl:variable name="target-cardinality" select="if ($history[2]) then 'unbounded' else $cardinality[2]"/> <!-- als materiele historie, dan is target altijd unbounded -->
                <xs:element
                    name="{$name-struct[7]}" 
                    type="{$terug-typeref}" 
                    nillable="true" 
                    minOccurs="0" 
                    maxOccurs="{$target-cardinality}"
                    metadata:formeleHistorie="{$history[1]}"
                    metadata:materieleHistorie="{$history[2]}"     
                />
                
            </xsl:otherwise>
        </xsl:choose>
    
    </xsl:template>
    
    <xsl:template match="imvert-result:Attribute" mode="declare-attribute-type">
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="type-struct" select="imf:get-typestruct(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="type-stereotype" select="imf:get-stereotype($type)"/>
        
        <xsl:comment select="concat('Attribute declaration ',$name-struct[4])"/>
        
        <xsl:if test="not($type-struct[1] = ('INDIC','URI')) and not($type-struct[2] = ('OnvolledigeDatum')) and not($type-stereotype = 'gegevensgroeptype')">
            <xsl:comment select="concat('Attribuut type (complex) ',$name-struct[4])"/>
            <xs:complexType name="{imf:capitalize($name-struct[3])}-e">
                <xs:simpleContent>
                    <xs:extension base="{$prefix}:{imf:capitalize($name-struct[3])}">
                        <xs:attributeGroup ref="StUF:element" />
                    </xs:extension>
                </xs:simpleContent>
            </xs:complexType>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="imvert-result:Association" mode="declare-association-type">
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="type-struct" select="imf:get-typestruct(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert-result:Class"/>
        <xsl:variable name="source-name-struct" select="imf:get-namestruct($source)"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        <xsl:variable name="target-name-struct" select="imf:get-namestruct($target)"/>
        
        <xsl:variable name="hisform-on-association" select="imf:get-history(.)[1]"/>
        <xsl:variable name="hismate-on-association" select="imf:get-history(.)[2]"/>
        
        <xsl:variable name="association-class" select="imf:get-by-id(imvert-result:associationClass/imvert-result:AssociationClassReference/imvert-result:typeId)"/>
        <xsl:variable name="association-class-attributes" select="$association-class//imvert-result:Attribute"/>
        
        <xsl:comment select="concat('Outgoing Association declaration ',$name-struct[4])"/>
    
        <xsl:variable name="associatie-naam" select="$name-struct[2]"/>
        
        <xs:complexType name="{$associatie-naam}-basis">
            <xs:annotation>
                <xs:documentation>
                    <?c3 volledige naam van de relatie in doc ?>
                    <xsl:value-of select="concat($name-struct[5],': ', imf:get-documentation(.))"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xs:element 
                    name="gerelateerde" 
                    type="{$prefix}:{$target-name-struct[2]}-basis"
                    nillable="true"
                    minOccurs="0"/>
                
                <!-- add the attributes of the association class, if any -->
                <xsl:apply-templates select="$association-class-attributes" mode="local-attribute"/>
                
                <xs:element ref="StUF:tijdvakRelatie" minOccurs="0"/>
                <xs:element ref="StUF:tijdstipRegistratie" minOccurs="0"/>
                <xs:element ref="StUF:extraElementen" minOccurs="0"/>
                <xsl:if test="exists($association-class) and $hismate-on-association">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="exists($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
                <xsl:if test="empty($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeelRelatie" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" fixed="{$associatie-naam}"/>
            <xs:attributeGroup ref="StUF:entiteit"/>
        </xs:complexType>
        
        <xsl:comment select="concat('Outgoing Association kerngegevens ',$name-struct[4])"/>
        
        <xs:complexType name="{$associatie-naam}-kerngegevens">
            <xs:annotation>
                <xs:documentation>Kerngegevens van de relatie</xs:documentation>
            </xs:annotation>
            <xs:complexContent>
                <xs:restriction base="{$prefix}:{$associatie-naam}-basis">
                    <xs:sequence>
                        <xs:element 
                            name="gerelateerde" 
                            type="{$prefix}:{$target-name-struct[2]}-kerngegevens"
                            nillable="true"
                            minOccurs="0"/>
                    </xs:sequence>
                    <!-- add the attributes of the association class, if any -->
                    <xsl:apply-templates select="$association-class-attributes" mode="local-attribute"/>
                    
                    <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$associatie-naam}"/>
                    <xs:attribute ref="StUF:sleutelVerzendend"/>
                    <xs:attribute ref="StUF:sleutelOntvangend"/>
                    <xs:attribute ref="StUF:sleutelGegevensbeheer"/>
                    <xs:attribute ref="StUF:noValue" use="prohibited"/>
                    <xs:attribute ref="StUF:scope" use="prohibited"/>
                    <xs:attribute ref="StUF:verwerkingssoort"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
        
        <xsl:comment select="concat('Incoming Association declaration ',$name-struct[4])"/>
        
        <xsl:variable name="associatie-naam" select="imf:get-taggedvalue(.,'Mnemonic relatiesoort terugrelatie')"/>
        <xsl:if test="not(normalize-space($associatie-naam))">
            <xsl:value-of select="imf:msg(.,'ERROR','No Menomonic specified for terugrelatie',())"/>
        </xsl:if>
        
        <xs:complexType name="{$associatie-naam}-basis">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="concat($name-struct[6],': ', imf:get-documentation(.))"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xs:element 
                    name="gerelateerde" 
                    type="{$prefix}:{$source-name-struct[2]}-basis"
                    nillable="true"
                    minOccurs="0"/>
                
                <!-- add the attributes of the association class, if any -->
                <xsl:apply-templates select="$association-class-attributes" mode="local-attribute"/>
                
                <xs:element ref="StUF:tijdvakRelatie" minOccurs="0"/>
                
                <xs:element 
                    ref="StUF:extraElementen" 
                    minOccurs="0"/>
                <xsl:if test="exists($association-class) and $hismate-on-association">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="exists($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
                <xsl:if test="empty($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeelRelatie" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" fixed="{$associatie-naam}"/>
            <xs:attributeGroup ref="StUF:entiteit"/>
        </xs:complexType>
    
        <xsl:comment select="concat('Incoming Association kerngegevens ',$name-struct[4])"/>
        
        <xs:complexType name="{$associatie-naam}-kerngegevens">
            <xs:annotation>
                <xs:documentation>Kerngegevens van de relatie</xs:documentation>
            </xs:annotation>
            <xs:complexContent>
                <xs:restriction base="{$prefix}:{$associatie-naam}-basis">
                    <xs:sequence>
                        <xs:element 
                            name="gerelateerde" 
                            type="{$prefix}:{$source-name-struct[2]}-kerngegevens"
                            nillable="true"
                            minOccurs="0"/>
                    </xs:sequence>
                    <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$associatie-naam}"/>
                    <xs:attribute ref="StUF:sleutelVerzendend"/>
                    <xs:attribute ref="StUF:sleutelOntvangend"/>
                    <xs:attribute ref="StUF:sleutelGegevensbeheer"/>
                    <xs:attribute ref="StUF:noValue" use="prohibited"/>
                    <xs:attribute ref="StUF:scope" use="prohibited"/>
                    <xs:attribute ref="StUF:verwerkingssoort"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
  
    </xsl:template>
    
    <xsl:template match="imvert-result:Attribute" mode="declare-attribute-simpletype">
        <xsl:variable name="name-struct" select="imf:get-namestruct(.)"/>
        <xsl:variable name="type-struct" select="imf:get-typestruct(.)"/>
        
        <xsl:variable name="maxlength" select="imvert-result:maxLength"/>
        <xsl:variable name="totaldigits" select="imvert-result:totalDigits"/>
        
        <xsl:if test="not($type-struct[1] = ('INDIC','URI')) and not($type-struct[2] = ('OnvolledigeDatum'))">
            <xsl:comment select="concat('Attribuut type (simple) ',$name-struct[4])"/>
            <xs:simpleType name="{imf:capitalize($name-struct[3])}">
                <xsl:choose>
                    <xsl:when test="$type-struct[1] = 'string'">
                        <xs:restriction base="xs:string">
                            <xs:maxLength value="{$maxlength}" />
                        </xs:restriction>
                    </xsl:when>
                    <xsl:when test="$type-struct[1] = 'letter'">
                        <xs:restriction base="xs:string">
                            <xs:maxLength value="1" />
                        </xs:restriction>
                    </xsl:when>
                    <xsl:when test="$type-struct[1] = 'integer'">
                        <xs:restriction base="xs:integer">
                            <xs:totalDigits value="{$totaldigits}" />
                        </xs:restriction>
                    </xsl:when>
                    <xsl:when test="$type-struct[1] = 'date'">
                        <xs:restriction base="xs:date"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="imf:msg(.,'ERROR','Cannot handle the attribute type', $type-struct[1])"/>
                    </xsl:otherwise>                
                </xsl:choose>
            </xs:simpleType>
        </xsl:if>
    </xsl:template>
      
    <xsl:function name="imf:get-namestruct" as="xs:string*">
        <xsl:param name="this"/>
        <xsl:if test="exists($this)">
            <xsl:variable name="type" select="local-name($this)"/>
            <xsl:variable name="stereotype" select="imf:get-stereotype($this)"/>
            <xsl:variable name="name" select="$this/imvert-result:identification/imvert-result:Identifiable/imvert-result:name"/>
            <xsl:variable name="original" select="$this/imvert-result:identification/imvert-result:Identifiable/imvert-result:originalName"/>
            <xsl:variable name="original-incoming" select="imf:get-taggedvalue($this,'Naam terugrelatie')"/>
            <xsl:variable name="alias" select="$this/imvert-result:identification/imvert-result:Identifiable/imvert-result:alias"/>
            <xsl:variable name="embellish-name" select="imf:get-construct-name($this)"/>
            <xsl:variable name="compiled-name">
                <xsl:choose>
                    <xsl:when test="$type = 'Class' and $stereotype = 'gegevensgroeptype'">
                        <xsl:value-of select="concat(imf:capitalize($alias),'Grp')"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Class' and $stereotype = 'objecttype'">
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Class' and $stereotype = 'relatieklasse'">
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Class' and $stereotype = 'referentielijst'">
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Attribute' and $stereotype = 'attribuutsoort' and normalize-space($alias)">
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Attribute' and $stereotype = 'attribuutsoort'">
                        <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                        <xsl:value-of select="lower-case($name)"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Attribute' and $stereotype = 'referentieelement'">
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Attribute'  and normalize-space($alias)"> <!-- composite -->
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Attribute'">
                        <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                        <xsl:value-of select="lower-case($name)"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Association' and $stereotype = 'relatiesoort' and normalize-space($alias)">
                        <!-- if this relation occurs multiple times, add the alias of the target object -->
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Association' and $stereotype = 'relatiesoort'">
                        <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                        <xsl:value-of select="lower-case($name)"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Association' and normalize-space($alias)"> <!-- composite -->
                        <xsl:value-of select="$alias"/>
                    </xsl:when>
                    <xsl:when test="$type = 'Association'">
                        <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                        <xsl:value-of select="lower-case($name)"/>
                    </xsl:when>
                    <!-- TODO meer soorten namen uitwerken? -->
                    <xsl:otherwise>
                        <xsl:sequence select="imf:msg($this,'ERROR','Unknown type [1] with stereo [2]', ($type, $stereotype))"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            
            <xsl:variable name="suffix" select="if ($type = 'Association') then imf:get-relation-suffix($this) else ''"/>
            
            <xsl:variable name="source-alias" select="$this/imvert-result:sourceAlias"/>
            <xsl:variable name="target-alias" select="$this/imvert-result:targetAlias"/>
            
            <xsl:sequence select="(
                normalize-space($name),
                normalize-space($alias),
                normalize-space($compiled-name),
                normalize-space($embellish-name),
                normalize-space($original),
                normalize-space($original-incoming),
                normalize-space(concat($source-alias,$suffix[1])),
                normalize-space(concat($target-alias,$suffix[2]))
                )"/>       
        </xsl:if>
    </xsl:function>

    <xsl:function name="imf:get-typestruct" as="xs:string*">
        <xsl:param name="this"/>
        <xsl:variable name="type" select="$this/imvert-result:type/imvert-result:Type"/>
        <xsl:variable name="typename" select="$type/imvert-result:typeName"/>
        <xsl:variable name="baretype" select="$type/imvert-result:baretype"/>
        <xsl:variable name="typeid" select="$type/imvert-result:typeId"/>
        <xsl:variable name="pack" select="$type/imvert-result:typePackage"/>
        <xsl:sequence select="(normalize-space($typename),normalize-space($baretype),normalize-space($typeid),normalize-space($pack))"/>
    </xsl:function>
    
    <xsl:function name="imf:get-cardinality" as="xs:string+">
        <xsl:param name="this"/>
        <xsl:variable name="source-min" select="$this/imvert-result:cardinality/imvert-result:Cardinal/imvert-result:minOccursSource"/>
        <xsl:variable name="source-max" select="$this/imvert-result:cardinality/imvert-result:Cardinal/imvert-result:maxOccursSource"/>
        <xsl:variable name="target-min" select="$this/imvert-result:cardinality/imvert-result:Cardinal/imvert-result:minOccurs"/>
        <xsl:variable name="target-max" select="$this/imvert-result:cardinality/imvert-result:Cardinal/imvert-result:maxOccurs"/>
        <xsl:sequence select="(normalize-space($source-min),normalize-space($source-max),normalize-space($target-min),normalize-space($target-max))"/>
    </xsl:function>
    
    <!-- return (formal?, material?) boolean values -->
    <xsl:function name="imf:get-history" as="xs:boolean+">
        <xsl:param name="this"/>
        <xsl:variable name="formal-this" select="imf:get-taggedvalue($this,'Indicatie formele historie')"/>
        <xsl:variable name="formal-grp" select="imf:get-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie formele historie')"/>
        <xsl:variable name="formal" select="if ($formal-this = 'zie groep') then $formal-grp else $formal-this"/>
        <xsl:variable name="material-this" select="imf:get-taggedvalue($this,'Indicatie materiële historie')"/>
        <xsl:variable name="material-grp" select="imf:get-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie materiële historie')"/>
        <xsl:variable name="material" select="if ($material-this = 'zie groep') then $material-grp else $material-this"/>
        <xsl:sequence select="(imf:boolean($this,$formal),imf:boolean($this,$material))"/>
    </xsl:function>

    <xsl:function name="imf:get-stereotype" as="xs:string*">
        <xsl:param name="this"/>
        <xsl:value-of select="$this/imvert-result:identification/imvert-result:Identifiable/imvert-result:stereotype"/>
    </xsl:function>

    <xsl:function name="imf:get-taggedvalue" as="xs:string?">
        <xsl:param name="this"/>
        <xsl:param name="name"/>
        <xsl:value-of select="$this/imvert-result:tags/imvert-result:TaggedValue[imvert-result:name = $name]/imvert-result:value"/>
    </xsl:function>
    
    <xsl:function name="imf:get-groepattribuutsoort" as="element()?">
        <xsl:param name="this" as="element()"/>
        <xsl:sequence select="$this/ancestor-or-self::imvert-result:Class[imf:get-stereotype(.) = 'gegevensgroeptype']"/>
    </xsl:function>
    
    <xsl:function name="imf:get-documentation">
        <xsl:param name="this"/>
        <xsl:value-of select="normalize-space($this/imvert-result:release/imvert-result:Released/imvert-result:documentation)"/>
    </xsl:function>
    
    <!-- tools -->
    
    <xsl:function name="imf:capitalize">
        <xsl:param name="name"/>
        <xsl:value-of select="concat(upper-case(substring($name,1,1)),substring($name,2))"/>
    </xsl:function>
    
    <xsl:function name="imf:boolean" as="xs:boolean">
        <xsl:param name="this"/>
        <xsl:param name="value"/>
        <xsl:sequence select="$value eq 'Ja'"/>
    </xsl:function>

    <!-- 
        ============================================== 
        common for all model based stylesheets 
        ============================================== 
    -->
    
    <xsl:function name="imf:get-construct-name" as="item()*">
        <xsl:param name="this" as="element()"/>
        <xsl:variable name="name" select="imf:sub-name($this)"/>
        <xsl:variable name="package-name" select="imf:sub-name($this/ancestor-or-self::imvert-result:Package[1])"/>
        <xsl:variable name="class-name" select="imf:sub-name($this/ancestor-or-self::imvert-result:Class[1])"/>
        <xsl:choose>
            <xsl:when test="$this/self::imvert-result:Package">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert-result:base">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert-result:Class">
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert-result:Type">
                <xsl:sequence select="imf:compile-construct-name($this/imvert-result:typePackage,$this/imvert-result:typeName,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert-result:Attribute">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'attrib')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert-result:Association[not(imf:sub-name(.))]">
                <xsl:variable name="type" select="concat('[',$this/imvert-result:type/imvert-result:Type/imvert-result:typeName,']')"/>
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$type,'aggr')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert-result:Association">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'assoc')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,local-name($this),'')"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="imf:sub-name">
        <xsl:param name="this"/>
        <xsl:value-of select="$this/imvert-result:identification/imvert-result:Identifiable/imvert-result:name"/>
    </xsl:function>

    <xsl:function name="imf:get-class" as="element()?">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="imf:get-typestruct($this)[3]"/>
        <xsl:if test="normalize-space($id)">
            <xsl:variable name="class" select="root($this)//imvert-result:Class[imf:get-id(.) = $id]"/>
            <xsl:sequence select="$class"/>
        </xsl:if>
    </xsl:function>

    <xsl:function name="imf:stub-create-name">
        <xsl:param name="literal-name"/>
        <xsl:value-of select="concat('STUB-',replace($literal-name,'[^a-zA-Z]','_'))"/>
    </xsl:function>

    <xsl:function name="imf:parse-names" as="xs:string*">
        <xsl:param name="text" as="xs:string"/>
        <xsl:analyze-string select="$text" regex="'(.+?)'">
            <xsl:matching-substring>
                <xsl:value-of select="regex-group(1)"/>
            </xsl:matching-substring>
        </xsl:analyze-string>
    </xsl:function>
    
    <xsl:function name="imf:get-kerngegevens" as="node()*">
        <xsl:param name="class"/>
        <xsl:variable name="tv" select="imf:get-taggedvalue($class,'Unieke aanduiding objecttype')"/>
        <xsl:variable name="selected-names" select="if (exists($tv)) then imf:parse-names($tv) else ()"/> <!-- de strings tussen '' in de beschrijving -->
        <xsl:variable name="selected-attributes" as="node()*">
            <xsl:choose>
                <xsl:when test="not($tv)"/>
                <xsl:when test="contains($tv,'in combinatie met')">
                    <xsl:sequence select="for $n in subsequence($selected-names,1,count($selected-names) - 1) return imf:get-kerngegevens-attributes($n,$class)"/>
                    <!-- and recursively add the kerngegevens of the relation with the mentioned class -->
                    <xsl:variable name="related-id" select="imf:get-id($document//imvert-result:Class[.//imvert-result:originalName = $selected-names[last()]][1])"/>
                    <xsl:variable name="relation" select="$class//imvert-result:Association[.//imvert-result:Type/imvert-result:typeId = $related-id]"/>
                    <xsl:sequence select="$relation[1]"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="for $n in $selected-names return imf:get-kerngegevens-attributes($n,$class)"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:sequence select="$selected-attributes"/>
    </xsl:function>

    <xsl:function name="imf:get-kerngegevens-attributes" as="element()*">
        <xsl:param name="attspec"/> <!-- eg. 'Besluittype-omschrijving generiek'-->
        <xsl:param name="class"/> <!-- de klasse waar het attribuut op is gedefinieerd -->
        <xsl:variable name="cls-namestruct" select="imf:get-namestruct($class)"/>
        <xsl:variable name="att" select="$class//imvert-result:Attribute[imvert-result:identification//imvert-result:originalName = $attspec]"/>
        <xsl:variable name="att-namestruct" select="imf:get-namestruct($att)"/>
        <xsl:choose>
            <xsl:when test="empty($att)">
                <xsl:sequence select="imf:msg($class,'ERROR','Kerngegevens attribute not found: [1].[2]', ($cls-namestruct[1],$attspec))"/>
            </xsl:when>
            <xsl:when test="not($att-namestruct[2])">
                <xsl:sequence select="imf:msg($att,'ERROR','No alias for attribute: [1].[2]', ($cls-namestruct[1],$att-namestruct[1]))"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="$att"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="imf:get-by-id" as="element()?">
        <xsl:param name="id"/>
        <xsl:sequence select="$document//*[imf:get-id(.) = $id]"/>
    </xsl:function>
    
    <xsl:function name="imf:get-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert-result:identification/imvert-result:Identifiable/imvert-result:id"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- get the ID of the type of the attribute or association -->
    <xsl:function name="imf:get-type-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert-result:type//imvert-result:Type/imvert-result:typeId"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- return suffixes to append to relation names. [1] is incoming, [2] is outgoing -->
    <xsl:function name="imf:get-relation-suffix" as="xs:string+">
        <xsl:param name="this"/> <!-- an Association element -->
        <xsl:variable name="targetAlias" select="$this/imvert-result:targetAlias"/>
        <xsl:variable name="targetId" select="imf:get-type-id($this)"/>
        
        <xsl:variable name="other-associations" select="root($this)//imvert-result:Association[imvert-result:targetAlias = $targetAlias and imf:get-type-id(.) = $targetId]"/>
        <xsl:variable name="class" select="$this/ancestor::imvert-result:Class"/>
        <xsl:value-of select="if (count($other-associations) gt 1) then imf:capitalize(imf:get-namestruct($class)[1]) else ''"/>

        <xsl:variable name="class" select="root($this)//imvert-result:Class[imf:get-id(.) = $targetId]"/>
        <xsl:value-of select="if (count($this/../imvert-result:Association[imvert-result:targetAlias = $targetAlias]) gt 1) then imf:capitalize(imf:get-namestruct($class)[1]) else ''"/>

    </xsl:function>
    
    <!-- =================== cleanup =================== -->
   
    <xsl:template match="xs:schema" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:variable name="names" select="for $n in (xs:*/@name) return string($n)" as="xs:string*"/>
            <xsl:variable name="names-dup" select="distinct-values($names[count(index-of($names,.)) gt 1])"/>
            <xsl:apply-templates mode="xsd-cleanup">
                <xsl:with-param name="names-dup" select="$names-dup"/>
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="xs:complexType | xs:simpleType" mode="xsd-cleanup">
        <xsl:param name="names-dup"/>
        <xsl:variable name="name" select="@name"/>
        <xsl:choose>
            <xsl:when test="($name = $names-dup) and (preceding-sibling::xs:*/@name = $name)">
                <!--<xsl:comment>DUPLICATE REMOVED</xsl:comment>-->
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="*" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="xsd-cleanup"/>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="comment()" mode="xsd-cleanup">
        <xsl:if test="$debug = 'true'">
            <xsl:sequence select="."/>
        </xsl:if>
    </xsl:template>
    
</xsl:stylesheet>
